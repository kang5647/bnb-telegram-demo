import{dU as C,dw as De,bO as F,ee as Te,ef as ye,am as Re}from"./index-D2QwjoYc.js";function Ge(i,e){for(var o=0;o<e.length;o++){const t=e[o];if(typeof t!="string"&&!Array.isArray(t)){for(const s in t)if(s!=="default"&&!(s in i)){const n=Object.getOwnPropertyDescriptor(t,s);n&&Object.defineProperty(i,s,n.get?n:{enumerable:!0,get:()=>t[s]})}}}return Object.freeze(Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}))}var Be={},J={},U={},Le={},ie={},_e={};/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */(function(i){(function(e){e(typeof DO_NOT_EXPORT_CRC>"u"?i:{})})(function(e){e.version="1.2.2";function o(){for(var c=0,w=new Array(256),f=0;f!=256;++f)c=f,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,c=c&1?-306674912^c>>>1:c>>>1,w[f]=c;return typeof Int32Array<"u"?new Int32Array(w):w}var t=o();function s(c){var w=0,f=0,b=0,$=typeof Int32Array<"u"?new Int32Array(4096):new Array(4096);for(b=0;b!=256;++b)$[b]=c[b];for(b=0;b!=256;++b)for(f=c[b],w=256+b;w<4096;w+=256)f=$[w]=f>>>8^c[f&255];var T=[];for(b=1;b!=16;++b)T[b-1]=typeof Int32Array<"u"?$.subarray(b*256,b*256+256):$.slice(b*256,b*256+256);return T}var n=s(t),a=n[0],r=n[1],d=n[2],m=n[3],u=n[4],h=n[5],P=n[6],y=n[7],E=n[8],H=n[9],L=n[10],j=n[11],_=n[12],k=n[13],A=n[14];function he(c,w){for(var f=w^-1,b=0,$=c.length;b<$;)f=f>>>8^t[(f^c.charCodeAt(b++))&255];return~f}function Q(c,w){for(var f=w^-1,b=c.length-15,$=0;$<b;)f=A[c[$++]^f&255]^k[c[$++]^f>>8&255]^_[c[$++]^f>>16&255]^j[c[$++]^f>>>24]^L[c[$++]]^H[c[$++]]^E[c[$++]]^y[c[$++]]^P[c[$++]]^h[c[$++]]^u[c[$++]]^m[c[$++]]^d[c[$++]]^r[c[$++]]^a[c[$++]]^t[c[$++]];for(b+=15;$<b;)f=f>>>8^t[(f^c[$++])&255];return~f}function Oe(c,w){for(var f=w^-1,b=0,$=c.length,T=0,le=0;b<$;)T=c.charCodeAt(b++),T<128?f=f>>>8^t[(f^T)&255]:T<2048?(f=f>>>8^t[(f^(192|T>>6&31))&255],f=f>>>8^t[(f^(128|T&63))&255]):T>=55296&&T<57344?(T=(T&1023)+64,le=c.charCodeAt(b++)&1023,f=f>>>8^t[(f^(240|T>>8&7))&255],f=f>>>8^t[(f^(128|T>>2&63))&255],f=f>>>8^t[(f^(128|le>>6&15|(T&3)<<4))&255],f=f>>>8^t[(f^(128|le&63))&255]):(f=f>>>8^t[(f^(224|T>>12&15))&255],f=f>>>8^t[(f^(128|T>>6&63))&255],f=f>>>8^t[(f^(128|T&63))&255]);return~f}e.table=t,e.bstr=he,e.buf=Q,e.str=Oe})})(_e);const Me="goerli",Ne=5,qe=5,ze="merge",Ue={type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},je="Cross-client PoA test network",Ke="https://github.com/goerli/testnet",Ve={timestamp:"0x5c51a607",gasLimit:10485760,difficulty:1,nonce:"0x0000000000000000",extraData:"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},Je=[{name:"chainstart",block:0,forkHash:"0xa3f5ab08"},{name:"homestead",block:0,forkHash:"0xa3f5ab08"},{name:"tangerineWhistle",block:0,forkHash:"0xa3f5ab08"},{name:"spuriousDragon",block:0,forkHash:"0xa3f5ab08"},{name:"byzantium",block:0,forkHash:"0xa3f5ab08"},{name:"constantinople",block:0,forkHash:"0xa3f5ab08"},{name:"petersburg",block:0,forkHash:"0xa3f5ab08"},{name:"istanbul",block:1561651,forkHash:"0xc25efa5c"},{name:"berlin",block:4460644,forkHash:"0x757a1c47"},{name:"london",block:5062605,forkHash:"0xb8c6299d"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",name:"merge",ttd:"10790000",block:7382819,forkHash:"0xb8c6299d"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,timestamp:"1678832736",forkHash:"0xf9843abf"}],Ye=[{ip:"51.141.78.53",port:30303,id:"011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",location:"",comment:"Upstream bootnode 1"},{ip:"13.93.54.137",port:30303,id:"176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",location:"",comment:"Upstream bootnode 2"},{ip:"94.237.54.114",port:30313,id:"46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",location:"",comment:"Upstream bootnode 3"},{ip:"18.218.250.66",port:30313,id:"b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",location:"",comment:"Upstream bootnode 4"},{ip:"3.11.147.67",port:30303,id:"a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",location:"",comment:"Ethereum Foundation bootnode"},{ip:"51.15.116.226",port:30303,id:"a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",location:"",comment:"Goerli Initiative bootnode"},{ip:"51.15.119.157",port:30303,id:"807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",location:"",comment:"Goerli Initiative bootnode"},{ip:"51.15.119.157",port:40303,id:"a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",location:"",comment:"Goerli Initiative bootnode"}],Xe=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"],We={name:Me,chainId:Ne,networkId:qe,defaultHardfork:ze,consensus:Ue,comment:je,url:Ke,genesis:Ve,hardforks:Je,bootstrapNodes:Ye,dnsNetworks:Xe},Ze="mainnet",Qe=1,et=1,tt="merge",ot={type:"pow",algorithm:"ethash",ethash:{}},st="The Ethereum main chain",nt="https://ethstats.net/",rt={gasLimit:5e3,difficulty:17179869184,nonce:"0x0000000000000042",extraData:"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"},at=[{name:"chainstart",block:0,forkHash:"0xfc64ec04"},{name:"homestead",block:115e4,forkHash:"0x97c2c34c"},{name:"dao",block:192e4,forkHash:"0x91d1f948"},{name:"tangerineWhistle",block:2463e3,forkHash:"0x7a64da13"},{name:"spuriousDragon",block:2675e3,forkHash:"0x3edd5b10"},{name:"byzantium",block:437e4,forkHash:"0xa00bc324"},{name:"constantinople",block:728e4,forkHash:"0x668db0af"},{name:"petersburg",block:728e4,forkHash:"0x668db0af"},{name:"istanbul",block:9069e3,forkHash:"0x879d6e30"},{name:"muirGlacier",block:92e5,forkHash:"0xe029e991"},{name:"berlin",block:12244e3,forkHash:"0x0eb440f6"},{name:"london",block:12965e3,forkHash:"0xb715077d"},{name:"arrowGlacier",block:13773e3,forkHash:"0x20c327fc"},{name:"grayGlacier",block:1505e4,forkHash:"0xf0afd0e3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",name:"merge",ttd:"58750000000000000000000",block:15537394,forkHash:"0xf0afd0e3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,timestamp:"1681338455",forkHash:"0xdce96c2d"}],it=[{ip:"18.138.108.67",port:30303,id:"d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",location:"ap-southeast-1-001",comment:"bootnode-aws-ap-southeast-1-001"},{ip:"3.209.45.79",port:30303,id:"22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",location:"us-east-1-001",comment:"bootnode-aws-us-east-1-001"},{ip:"65.108.70.101",port:30303,id:"2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc",location:"eu-west-1-001",comment:"bootnode-hetzner-hel"},{ip:"157.90.35.166",port:30303,id:"4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052",location:"eu-central-1-001",comment:"bootnode-hetzner-fsn"}],ct=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"],dt={name:Ze,chainId:Qe,networkId:et,defaultHardfork:tt,consensus:ot,comment:st,url:nt,genesis:rt,hardforks:at,bootstrapNodes:it,dnsNetworks:ct},ft="rinkeby",ut=4,mt=4,ht="london",lt={type:"poa",algorithm:"clique",clique:{period:15,epoch:3e4}},gt="PoA test network",pt="https://www.rinkeby.io",bt={timestamp:"0x58ee40ba",gasLimit:47e5,difficulty:1,nonce:"0x0000000000000000",extraData:"0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},vt=[{name:"chainstart",block:0,forkHash:"0x3b8e0691"},{name:"homestead",block:1,forkHash:"0x60949295"},{name:"tangerineWhistle",block:2,forkHash:"0x8bde40dd"},{name:"spuriousDragon",block:3,forkHash:"0xcb3a64bb"},{name:"byzantium",block:1035301,forkHash:"0x8d748b57"},{name:"constantinople",block:3660663,forkHash:"0xe49cab14"},{name:"petersburg",block:4321234,forkHash:"0xafec6b27"},{name:"istanbul",block:5435345,forkHash:"0xcbdb8838"},{name:"berlin",block:8290928,forkHash:"0x6910c8bd"},{name:"london",block:8897988,forkHash:"0x8e29f2f3"},{name:"merge",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],$t=[{ip:"52.169.42.101",port:30303,id:"a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",location:"",comment:"IE"},{ip:"52.3.158.184",port:30303,id:"343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",location:"",comment:"INFURA"},{ip:"159.89.28.211",port:30303,id:"b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",location:"",comment:"AKASHA"}],kt=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"],It={name:ft,chainId:ut,networkId:mt,defaultHardfork:ht,consensus:lt,comment:gt,url:pt,genesis:bt,hardforks:vt,bootstrapNodes:$t,dnsNetworks:kt},Pt="ropsten",Et=3,Tt=3,yt="merge",Bt={type:"pow",algorithm:"ethash",ethash:{}},wt="PoW test network",xt="https://github.com/ethereum/ropsten",St={gasLimit:16777216,difficulty:1048576,nonce:"0x0000000000000042",extraData:"0x3535353535353535353535353535353535353535353535353535353535353535"},At=[{name:"chainstart",block:0,forkHash:"0x30c7ddbc"},{name:"homestead",block:0,forkHash:"0x30c7ddbc"},{name:"tangerineWhistle",block:0,forkHash:"0x30c7ddbc"},{name:"spuriousDragon",block:10,forkHash:"0x63760190"},{name:"byzantium",block:17e5,forkHash:"0x3ea159c7"},{name:"constantinople",block:423e4,forkHash:"0x97b544f3"},{name:"petersburg",block:4939394,forkHash:"0xd6e2149b"},{name:"istanbul",block:6485846,forkHash:"0x4bc66396"},{name:"muirGlacier",block:7117117,forkHash:"0x6727ef90"},{name:"berlin",block:9812189,forkHash:"0xa157d377"},{name:"london",block:10499401,forkHash:"0x7119b6b3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge",name:"merge",ttd:"50000000000000000",block:null,forkHash:"0x7119b6b3"},{name:"mergeForkIdTransition",block:null,forkHash:null},{name:"shanghai",block:null,forkHash:null}],Ht=[{ip:"52.176.7.10",port:30303,id:"30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",location:"",comment:"US-Azure geth"},{ip:"52.176.100.77",port:30303,id:"865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",location:"",comment:"US-Azure parity"},{ip:"52.232.243.152",port:30303,id:"6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",location:"",comment:"Parity"},{ip:"192.81.208.223",port:30303,id:"94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",location:"",comment:"@gpip"}],Ct=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"],Lt={name:Pt,chainId:Et,networkId:Tt,defaultHardfork:yt,consensus:Bt,comment:wt,url:xt,genesis:St,hardforks:At,bootstrapNodes:Ht,dnsNetworks:Ct},_t="sepolia",Ft=11155111,Ot=11155111,Dt="merge",Rt={type:"pow",algorithm:"ethash",ethash:{}},Gt="PoW test network to replace Ropsten",Mt="https://github.com/ethereum/go-ethereum/pull/23730",Nt={timestamp:"0x6159af19",gasLimit:3e7,difficulty:131072,nonce:"0x0000000000000000",extraData:"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"},qt=[{name:"chainstart",block:0,forkHash:"0xfe3366e7"},{name:"homestead",block:0,forkHash:"0xfe3366e7"},{name:"tangerineWhistle",block:0,forkHash:"0xfe3366e7"},{name:"spuriousDragon",block:0,forkHash:"0xfe3366e7"},{name:"byzantium",block:0,forkHash:"0xfe3366e7"},{name:"constantinople",block:0,forkHash:"0xfe3366e7"},{name:"petersburg",block:0,forkHash:"0xfe3366e7"},{name:"istanbul",block:0,forkHash:"0xfe3366e7"},{name:"muirGlacier",block:0,forkHash:"0xfe3366e7"},{name:"berlin",block:0,forkHash:"0xfe3366e7"},{name:"london",block:0,forkHash:"0xfe3366e7"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",name:"merge",ttd:"17000000000000000",block:1450409,forkHash:"0xfe3366e7"},{name:"mergeForkIdTransition",block:1735371,forkHash:"0xb96cbd13"},{name:"shanghai",block:null,timestamp:"1677557088",forkHash:"0xf7f9bc08"}],zt=[{ip:"18.168.182.86",port:30303,id:"9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",location:"",comment:"geth"},{ip:"52.14.151.177",port:30303,id:"ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",location:"",comment:"besu"},{ip:"165.22.196.173",port:30303,id:"ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",location:"",comment:"EF"},{ip:"65.108.95.67",port:30303,id:"075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",location:"",comment:"lodestar"}],Ut=["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"],jt={name:_t,chainId:Ft,networkId:Ot,defaultHardfork:Dt,consensus:Rt,comment:Gt,url:Mt,genesis:Nt,hardforks:qt,bootstrapNodes:zt,dnsNetworks:Ut};var ce={};const Kt="EIP-1153",Vt=1153,Jt="Transient Storage",Yt="https://eips.ethereum.org/EIPS/eip-1153",Xt="Review",Wt="chainstart",Zt=[],Qt={},eo={tstore:{v:100,d:"Base fee of the TSTORE opcode"},tload:{v:100,d:"Base fee of the TLOAD opcode"}},to={},oo={},so={name:Kt,number:Vt,comment:Jt,url:Yt,status:Xt,minimumHardfork:Wt,requiredEIPs:Zt,gasConfig:Qt,gasPrices:eo,vm:to,pow:oo},no="EIP-1559",ro=1559,ao="Fee market change for ETH 1.0 chain",io="https://eips.ethereum.org/EIPS/eip-1559",co="Final",fo="berlin",uo=[2930],mo={baseFeeMaxChangeDenominator:{v:8,d:"Maximum base fee change denominator"},elasticityMultiplier:{v:2,d:"Maximum block gas target elasticity"},initialBaseFee:{v:1e9,d:"Initial base fee on first EIP1559 block"}},ho={},lo={},go={},po={name:no,number:ro,comment:ao,url:io,status:co,minimumHardfork:fo,requiredEIPs:uo,gasConfig:mo,gasPrices:ho,vm:lo,pow:go},bo="EIP-2315",vo=2315,$o="Simple subroutines for the EVM",ko="https://eips.ethereum.org/EIPS/eip-2315",Io="Draft",Po="istanbul",Eo={},To={beginsub:{v:2,d:"Base fee of the BEGINSUB opcode"},returnsub:{v:5,d:"Base fee of the RETURNSUB opcode"},jumpsub:{v:10,d:"Base fee of the JUMPSUB opcode"}},yo={},Bo={},wo={name:bo,number:vo,comment:$o,url:ko,status:Io,minimumHardfork:Po,gasConfig:Eo,gasPrices:To,vm:yo,pow:Bo},xo="EIP-2537",So=2537,Ao="BLS12-381 precompiles",Ho="https://eips.ethereum.org/EIPS/eip-2537",Co="Draft",Lo="chainstart",_o={},Fo={Bls12381G1AddGas:{v:600,d:"Gas cost of a single BLS12-381 G1 addition precompile-call"},Bls12381G1MulGas:{v:12e3,d:"Gas cost of a single BLS12-381 G1 multiplication precompile-call"},Bls12381G2AddGas:{v:4500,d:"Gas cost of a single BLS12-381 G2 addition precompile-call"},Bls12381G2MulGas:{v:55e3,d:"Gas cost of a single BLS12-381 G2 multiplication precompile-call"},Bls12381PairingBaseGas:{v:115e3,d:"Base gas cost of BLS12-381 pairing check"},Bls12381PairingPerPairGas:{v:23e3,d:"Per-pair gas cost of BLS12-381 pairing check"},Bls12381MapG1Gas:{v:5500,d:"Gas cost of BLS12-381 map field element to G1"},Bls12381MapG2Gas:{v:11e4,d:"Gas cost of BLS12-381 map field element to G2"},Bls12381MultiExpGasDiscount:{v:[[1,1200],[2,888],[3,764],[4,641],[5,594],[6,547],[7,500],[8,453],[9,438],[10,423],[11,408],[12,394],[13,379],[14,364],[15,349],[16,334],[17,330],[18,326],[19,322],[20,318],[21,314],[22,310],[23,306],[24,302],[25,298],[26,294],[27,289],[28,285],[29,281],[30,277],[31,273],[32,269],[33,268],[34,266],[35,265],[36,263],[37,262],[38,260],[39,259],[40,257],[41,256],[42,254],[43,253],[44,251],[45,250],[46,248],[47,247],[48,245],[49,244],[50,242],[51,241],[52,239],[53,238],[54,236],[55,235],[56,233],[57,232],[58,231],[59,229],[60,228],[61,226],[62,225],[63,223],[64,222],[65,221],[66,220],[67,219],[68,219],[69,218],[70,217],[71,216],[72,216],[73,215],[74,214],[75,213],[76,213],[77,212],[78,211],[79,211],[80,210],[81,209],[82,208],[83,208],[84,207],[85,206],[86,205],[87,205],[88,204],[89,203],[90,202],[91,202],[92,201],[93,200],[94,199],[95,199],[96,198],[97,197],[98,196],[99,196],[100,195],[101,194],[102,193],[103,193],[104,192],[105,191],[106,191],[107,190],[108,189],[109,188],[110,188],[111,187],[112,186],[113,185],[114,185],[115,184],[116,183],[117,182],[118,182],[119,181],[120,180],[121,179],[122,179],[123,178],[124,177],[125,176],[126,176],[127,175],[128,174]],d:"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"}},Oo={},Do={},Ro={name:xo,number:So,comment:Ao,url:Ho,status:Co,minimumHardfork:Lo,gasConfig:_o,gasPrices:Fo,vm:Oo,pow:Do},Go="EIP-2565",Mo=2565,No="ModExp gas cost",qo="https://eips.ethereum.org/EIPS/eip-2565",zo="Final",Uo="byzantium",jo={},Ko={modexpGquaddivisor:{v:3,d:"Gquaddivisor from modexp precompile for gas calculation"}},Vo={},Jo={},Yo={name:Go,number:Mo,comment:No,url:qo,status:zo,minimumHardfork:Uo,gasConfig:jo,gasPrices:Ko,vm:Vo,pow:Jo},Xo="EIP-2718",Wo="Typed Transaction Envelope",Zo="https://eips.ethereum.org/EIPS/eip-2718",Qo="Final",es="chainstart",ts={},os={},ss={},ns={},rs={name:Xo,comment:Wo,url:Zo,status:Qo,minimumHardfork:es,gasConfig:ts,gasPrices:os,vm:ss,pow:ns},as="EIP-2929",is="Gas cost increases for state access opcodes",cs="https://eips.ethereum.org/EIPS/eip-2929",ds="Final",fs="chainstart",us={},ms={coldsload:{v:2100,d:"Gas cost of the first read of storage from a given location (per transaction)"},coldaccountaccess:{v:2600,d:"Gas cost of the first read of a given address (per transaction)"},warmstorageread:{v:100,d:"Gas cost of reading storage locations which have already loaded 'cold'"},sstoreCleanGasEIP2200:{v:2900,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreNoopGasEIP2200:{v:100,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:100,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitRefundEIP2200:{v:19900,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanRefundEIP2200:{v:4900,d:"Once per SSTORE operation for resetting to the original non-zero value"},call:{v:0,d:"Base fee of the CALL opcode"},callcode:{v:0,d:"Base fee of the CALLCODE opcode"},delegatecall:{v:0,d:"Base fee of the DELEGATECALL opcode"},staticcall:{v:0,d:"Base fee of the STATICCALL opcode"},balance:{v:0,d:"Base fee of the BALANCE opcode"},extcodesize:{v:0,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:0,d:"Base fee of the EXTCODECOPY opcode"},extcodehash:{v:0,d:"Base fee of the EXTCODEHASH opcode"},sload:{v:0,d:"Base fee of the SLOAD opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"}},hs={},ls={},gs={name:as,comment:is,url:cs,status:ds,minimumHardfork:fs,gasConfig:us,gasPrices:ms,vm:hs,pow:ls},ps="EIP-2930",bs="Optional access lists",vs="https://eips.ethereum.org/EIPS/eip-2930",$s="Final",ks="istanbul",Is=[2718,2929],Ps={},Es={accessListStorageKeyCost:{v:1900,d:"Gas cost per storage key in an Access List transaction"},accessListAddressCost:{v:2400,d:"Gas cost per storage key in an Access List transaction"}},Ts={},ys={},Bs={name:ps,comment:bs,url:vs,status:$s,minimumHardfork:ks,requiredEIPs:Is,gasConfig:Ps,gasPrices:Es,vm:Ts,pow:ys},ws="EIP-3074",xs=3074,Ss="AUTH and AUTHCALL opcodes",As="https://eips.ethereum.org/EIPS/eip-3074",Hs="Review",Cs="london",Ls={},_s={auth:{v:3100,d:"Gas cost of the AUTH opcode"},authcall:{v:0,d:"Gas cost of the AUTHCALL opcode"},authcallValueTransfer:{v:6700,d:"Paid for CALL when the value transfer is non-zero"}},Fs={},Os={},Ds={name:ws,number:xs,comment:Ss,url:As,status:Hs,minimumHardfork:Cs,gasConfig:Ls,gasPrices:_s,vm:Fs,pow:Os},Rs="EIP-3198",Gs=3198,Ms="BASEFEE opcode",Ns="https://eips.ethereum.org/EIPS/eip-3198",qs="Final",zs="london",Us={},js={basefee:{v:2,d:"Gas cost of the BASEFEE opcode"}},Ks={},Vs={},Js={name:Rs,number:Gs,comment:Ms,url:Ns,status:qs,minimumHardfork:zs,gasConfig:Us,gasPrices:js,vm:Ks,pow:Vs},Ys="EIP-3529",Xs="Reduction in refunds",Ws="https://eips.ethereum.org/EIPS/eip-3529",Zs="Final",Qs="berlin",en=[2929],tn={maxRefundQuotient:{v:5,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},on={selfdestructRefund:{v:0,d:"Refunded following a selfdestruct operation"},sstoreClearRefundEIP2200:{v:4800,d:"Once per SSTORE operation for clearing an originally existing storage slot"}},sn={},nn={},rn={name:Ys,comment:Xs,url:Ws,status:Zs,minimumHardfork:Qs,requiredEIPs:en,gasConfig:tn,gasPrices:on,vm:sn,pow:nn},an="EIP-3540",cn=3540,dn="EVM Object Format (EOF) v1",fn="https://eips.ethereum.org/EIPS/eip-3540",un="Review",mn="london",hn=[3541],ln={},gn={},pn={},bn={},vn={name:an,number:cn,comment:dn,url:fn,status:un,minimumHardfork:mn,requiredEIPs:hn,gasConfig:ln,gasPrices:gn,vm:pn,pow:bn},$n="EIP-3541",kn="Reject new contracts starting with the 0xEF byte",In="https://eips.ethereum.org/EIPS/eip-3541",Pn="Final",En="berlin",Tn=[],yn={},Bn={},wn={},xn={},Sn={name:$n,comment:kn,url:In,status:Pn,minimumHardfork:En,requiredEIPs:Tn,gasConfig:yn,gasPrices:Bn,vm:wn,pow:xn},An="EIP-3554",Hn="Reduction in refunds",Cn="Difficulty Bomb Delay to December 1st 2021",Ln="Final",_n="muirGlacier",Fn=[],On={},Dn={},Rn={},Gn={difficultyBombDelay:{v:95e5,d:"the amount of blocks to delay the difficulty bomb with"}},Mn={name:An,comment:Hn,url:Cn,status:Ln,minimumHardfork:_n,requiredEIPs:Fn,gasConfig:On,gasPrices:Dn,vm:Rn,pow:Gn},Nn="EIP-3607",qn=3607,zn="Reject transactions from senders with deployed code",Un="https://eips.ethereum.org/EIPS/eip-3607",jn="Final",Kn="chainstart",Vn=[],Jn={},Yn={},Xn={},Wn={},Zn={name:Nn,number:qn,comment:zn,url:Un,status:jn,minimumHardfork:Kn,requiredEIPs:Vn,gasConfig:Jn,gasPrices:Yn,vm:Xn,pow:Wn},Qn="EIP-3651",er=3198,tr="Warm COINBASE",or="https://eips.ethereum.org/EIPS/eip-3651",sr="Review",nr="london",rr=[2929],ar={},ir={},cr={},dr={},fr={name:Qn,number:er,comment:tr,url:or,status:sr,minimumHardfork:nr,requiredEIPs:rr,gasConfig:ar,gasPrices:ir,vm:cr,pow:dr},ur="EIP-3670",mr=3670,hr="EOF - Code Validation",lr="https://eips.ethereum.org/EIPS/eip-3670",gr="Review",pr="london",br=[3540],vr={},$r={},kr={},Ir={},Pr={name:ur,number:mr,comment:hr,url:lr,status:gr,minimumHardfork:pr,requiredEIPs:br,gasConfig:vr,gasPrices:$r,vm:kr,pow:Ir},Er="EIP-3675",Tr=3675,yr="Upgrade consensus to Proof-of-Stake",Br="https://eips.ethereum.org/EIPS/eip-3675",wr="Final",xr="london",Sr=[],Ar={},Hr={},Cr={},Lr={},_r={name:Er,number:Tr,comment:yr,url:Br,status:wr,minimumHardfork:xr,requiredEIPs:Sr,gasConfig:Ar,gasPrices:Hr,vm:Cr,pow:Lr},Fr="EIP-3855",Or=3855,Dr="PUSH0 instruction",Rr="https://eips.ethereum.org/EIPS/eip-3855",Gr="Review",Mr="chainstart",Nr=[],qr={},zr={push0:{v:2,d:"Base fee of the PUSH0 opcode"}},Ur={},jr={},Kr={name:Fr,number:Or,comment:Dr,url:Rr,status:Gr,minimumHardfork:Mr,requiredEIPs:Nr,gasConfig:qr,gasPrices:zr,vm:Ur,pow:jr},Vr="EIP-3860",Jr=3860,Yr="Limit and meter initcode",Xr="https://eips.ethereum.org/EIPS/eip-3860",Wr="Review",Zr="spuriousDragon",Qr=[],ea={},ta={initCodeWordCost:{v:2,d:"Gas to pay for each word (32 bytes) of initcode when creating a contract"}},oa={maxInitCodeSize:{v:49152,d:"Maximum length of initialization code when creating a contract"}},sa={},na={name:Vr,number:Jr,comment:Yr,url:Xr,status:Wr,minimumHardfork:Zr,requiredEIPs:Qr,gasConfig:ea,gasPrices:ta,vm:oa,pow:sa},ra="EIP-4345",aa=4345,ia="Difficulty Bomb Delay to June 2022",ca="https://eips.ethereum.org/EIPS/eip-4345",da="Final",fa="london",ua={},ma={},ha={},la={difficultyBombDelay:{v:107e5,d:"the amount of blocks to delay the difficulty bomb with"}},ga={name:ra,number:aa,comment:ia,url:ca,status:da,minimumHardfork:fa,gasConfig:ua,gasPrices:ma,vm:ha,pow:la},pa="EIP-4399",ba=4399,va="Supplant DIFFICULTY opcode with PREVRANDAO",$a="https://eips.ethereum.org/EIPS/eip-4399",ka="Review",Ia="london",Pa=[],Ea={},Ta={},ya={},Ba={},wa={name:pa,number:ba,comment:va,url:$a,status:ka,minimumHardfork:Ia,requiredEIPs:Pa,gasConfig:Ea,gasPrices:Ta,vm:ya,pow:Ba},xa="EIP-4844",Sa=4844,Aa="Shard Blob Transactions",Ha="https://eips.ethereum.org/EIPS/eip-4844",Ca="Draft",La="merge",_a=[1559,2718,2930,4895],Fa={dataGasPerBlob:{v:131072,d:"The base fee for data gas per blob"},targetDataGasPerBlock:{v:262144,d:"The target data gas consumed per block"},maxDataGasPerBlock:{v:524288,d:"The max data gas allowable per block"},dataGasPriceUpdateFraction:{v:2225652,d:"The denominator used in the exponential when calculating a data gas price"}},Oa={simpleGasPerBlob:{v:12e3,d:"The basic gas fee for each blob"},minDataGasPrice:{v:1,d:"The minimum fee per data gas"},kzgPointEvaluationGasPrecompilePrice:{v:5e4,d:"The fee associated with the point evaluation precompile"},datahash:{v:3,d:"Base fee of the DATAHASH opcode"}},Da={blobCommitmentVersionKzg:{v:1,d:"The number indicated a versioned hash is a KZG commitment"},fieldElementsPerBlob:{v:4096,d:"The number of field elements allowed per blob"}},Ra={},Ga={},Ma={name:xa,number:Sa,comment:Aa,url:Ha,status:Ca,minimumHardfork:La,requiredEIPs:_a,gasConfig:Fa,gasPrices:Oa,sharding:Da,vm:Ra,pow:Ga},Na="EIP-4895",qa=4895,za="Beacon chain push withdrawals as operations",Ua="https://eips.ethereum.org/EIPS/eip-4895",ja="Review",Ka="merge",Va=[],Ja={},Ya={},Xa={},Wa={},Za={name:Na,number:qa,comment:za,url:Ua,status:ja,minimumHardfork:Ka,requiredEIPs:Va,gasConfig:Ja,gasPrices:Ya,vm:Xa,pow:Wa},Qa="EIP-5133",ei=5133,ti="Delaying Difficulty Bomb to mid-September 2022",oi="https://eips.ethereum.org/EIPS/eip-5133",si="Draft",ni="grayGlacier",ri={},ai={},ii={},ci={difficultyBombDelay:{v:114e5,d:"the amount of blocks to delay the difficulty bomb with"}},di={name:Qa,number:ei,comment:ti,url:oi,status:si,minimumHardfork:ni,gasConfig:ri,gasPrices:ai,vm:ii,pow:ci};Object.defineProperty(ce,"__esModule",{value:!0});ce.EIPs=void 0;ce.EIPs={1153:so,1559:po,2315:wo,2537:Ro,2565:Yo,2718:rs,2929:gs,2930:Bs,3074:Ds,3198:Js,3529:rn,3540:vn,3541:Sn,3554:Mn,3607:Zn,3651:fr,3670:Pr,3675:_r,3855:Kr,3860:na,4345:ga,4399:wa,4844:Ma,4895:Za,5133:di};var de={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.CustomChain=i.ConsensusAlgorithm=i.ConsensusType=i.Hardfork=i.Chain=void 0,function(e){e[e.Mainnet=1]="Mainnet",e[e.Ropsten=3]="Ropsten",e[e.Rinkeby=4]="Rinkeby",e[e.Goerli=5]="Goerli",e[e.Sepolia=11155111]="Sepolia"}(i.Chain||(i.Chain={})),function(e){e.Chainstart="chainstart",e.Homestead="homestead",e.Dao="dao",e.TangerineWhistle="tangerineWhistle",e.SpuriousDragon="spuriousDragon",e.Byzantium="byzantium",e.Constantinople="constantinople",e.Petersburg="petersburg",e.Istanbul="istanbul",e.MuirGlacier="muirGlacier",e.Berlin="berlin",e.London="london",e.ArrowGlacier="arrowGlacier",e.GrayGlacier="grayGlacier",e.MergeForkIdTransition="mergeForkIdTransition",e.Merge="merge",e.Shanghai="shanghai",e.ShardingForkDev="shardingFork"}(i.Hardfork||(i.Hardfork={})),function(e){e.ProofOfStake="pos",e.ProofOfWork="pow",e.ProofOfAuthority="poa"}(i.ConsensusType||(i.ConsensusType={})),function(e){e.Ethash="ethash",e.Clique="clique",e.Casper="casper"}(i.ConsensusAlgorithm||(i.ConsensusAlgorithm={})),function(e){e.PolygonMainnet="polygon-mainnet",e.PolygonMumbai="polygon-mumbai",e.ArbitrumRinkebyTestnet="arbitrum-rinkeby-testnet",e.ArbitrumOne="arbitrum-one",e.xDaiChain="x-dai-chain",e.OptimisticKovan="optimistic-kovan",e.OptimisticEthereum="optimistic-ethereum"}(i.CustomChain||(i.CustomChain={}))})(de);var fe={};const fi="chainstart",ui="Start of the Ethereum main chain",mi="",hi="",li={minGasLimit:{v:5e3,d:"Minimum the gas limit may ever be"},gasLimitBoundDivisor:{v:1024,d:"The bound divisor of the gas limit, used in update calculations"},maxRefundQuotient:{v:2,d:"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},gi={base:{v:2,d:"Gas base cost, used e.g. for ChainID opcode (Istanbul)"},tierStep:{v:[0,2,3,5,8,10,20],d:"Once per operation, for a selection of them"},exp:{v:10,d:"Base fee of the EXP opcode"},expByte:{v:10,d:"Times ceil(log256(exponent)) for the EXP instruction"},sha3:{v:30,d:"Base fee of the SHA3 opcode"},sha3Word:{v:6,d:"Once per word of the SHA3 operation's data"},sload:{v:50,d:"Base fee of the SLOAD opcode"},sstoreSet:{v:2e4,d:"Once per SSTORE operation if the zeroness changes from zero"},sstoreReset:{v:5e3,d:"Once per SSTORE operation if the zeroness does not change from zero"},sstoreRefund:{v:15e3,d:"Once per SSTORE operation if the zeroness changes to zero"},jumpdest:{v:1,d:"Base fee of the JUMPDEST opcode"},log:{v:375,d:"Base fee of the LOG opcode"},logData:{v:8,d:"Per byte in a LOG* operation's data"},logTopic:{v:375,d:"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"},create:{v:32e3,d:"Base fee of the CREATE opcode"},call:{v:40,d:"Base fee of the CALL opcode"},callStipend:{v:2300,d:"Free gas given at beginning of call"},callValueTransfer:{v:9e3,d:"Paid for CALL when the value transfor is non-zero"},callNewAccount:{v:25e3,d:"Paid for CALL when the destination address didn't exist prior"},selfdestructRefund:{v:24e3,d:"Refunded following a selfdestruct operation"},memory:{v:3,d:"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"},quadCoeffDiv:{v:512,d:"Divisor for the quadratic particle of the memory cost equation"},createData:{v:200,d:""},tx:{v:21e3,d:"Per transaction. NOTE: Not payable on data of calls between transactions"},txCreation:{v:32e3,d:"The cost of creating a contract via tx"},txDataZero:{v:4,d:"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"},txDataNonZero:{v:68,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},copy:{v:3,d:"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"},ecRecover:{v:3e3,d:""},sha256:{v:60,d:""},sha256Word:{v:12,d:""},ripemd160:{v:600,d:""},ripemd160Word:{v:120,d:""},identity:{v:15,d:""},identityWord:{v:3,d:""},stop:{v:0,d:"Base fee of the STOP opcode"},add:{v:3,d:"Base fee of the ADD opcode"},mul:{v:5,d:"Base fee of the MUL opcode"},sub:{v:3,d:"Base fee of the SUB opcode"},div:{v:5,d:"Base fee of the DIV opcode"},sdiv:{v:5,d:"Base fee of the SDIV opcode"},mod:{v:5,d:"Base fee of the MOD opcode"},smod:{v:5,d:"Base fee of the SMOD opcode"},addmod:{v:8,d:"Base fee of the ADDMOD opcode"},mulmod:{v:8,d:"Base fee of the MULMOD opcode"},signextend:{v:5,d:"Base fee of the SIGNEXTEND opcode"},lt:{v:3,d:"Base fee of the LT opcode"},gt:{v:3,d:"Base fee of the GT opcode"},slt:{v:3,d:"Base fee of the SLT opcode"},sgt:{v:3,d:"Base fee of the SGT opcode"},eq:{v:3,d:"Base fee of the EQ opcode"},iszero:{v:3,d:"Base fee of the ISZERO opcode"},and:{v:3,d:"Base fee of the AND opcode"},or:{v:3,d:"Base fee of the OR opcode"},xor:{v:3,d:"Base fee of the XOR opcode"},not:{v:3,d:"Base fee of the NOT opcode"},byte:{v:3,d:"Base fee of the BYTE opcode"},address:{v:2,d:"Base fee of the ADDRESS opcode"},balance:{v:20,d:"Base fee of the BALANCE opcode"},origin:{v:2,d:"Base fee of the ORIGIN opcode"},caller:{v:2,d:"Base fee of the CALLER opcode"},callvalue:{v:2,d:"Base fee of the CALLVALUE opcode"},calldataload:{v:3,d:"Base fee of the CALLDATALOAD opcode"},calldatasize:{v:2,d:"Base fee of the CALLDATASIZE opcode"},calldatacopy:{v:3,d:"Base fee of the CALLDATACOPY opcode"},codesize:{v:2,d:"Base fee of the CODESIZE opcode"},codecopy:{v:3,d:"Base fee of the CODECOPY opcode"},gasprice:{v:2,d:"Base fee of the GASPRICE opcode"},extcodesize:{v:20,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:20,d:"Base fee of the EXTCODECOPY opcode"},blockhash:{v:20,d:"Base fee of the BLOCKHASH opcode"},coinbase:{v:2,d:"Base fee of the COINBASE opcode"},timestamp:{v:2,d:"Base fee of the TIMESTAMP opcode"},number:{v:2,d:"Base fee of the NUMBER opcode"},difficulty:{v:2,d:"Base fee of the DIFFICULTY opcode"},gaslimit:{v:2,d:"Base fee of the GASLIMIT opcode"},pop:{v:2,d:"Base fee of the POP opcode"},mload:{v:3,d:"Base fee of the MLOAD opcode"},mstore:{v:3,d:"Base fee of the MSTORE opcode"},mstore8:{v:3,d:"Base fee of the MSTORE8 opcode"},sstore:{v:0,d:"Base fee of the SSTORE opcode"},jump:{v:8,d:"Base fee of the JUMP opcode"},jumpi:{v:10,d:"Base fee of the JUMPI opcode"},pc:{v:2,d:"Base fee of the PC opcode"},msize:{v:2,d:"Base fee of the MSIZE opcode"},gas:{v:2,d:"Base fee of the GAS opcode"},push:{v:3,d:"Base fee of the PUSH opcode"},dup:{v:3,d:"Base fee of the DUP opcode"},swap:{v:3,d:"Base fee of the SWAP opcode"},callcode:{v:40,d:"Base fee of the CALLCODE opcode"},return:{v:0,d:"Base fee of the RETURN opcode"},invalid:{v:0,d:"Base fee of the INVALID opcode"},selfdestruct:{v:0,d:"Base fee of the SELFDESTRUCT opcode"}},pi={stackLimit:{v:1024,d:"Maximum size of VM stack allowed"},callCreateDepth:{v:1024,d:"Maximum depth of call/create stack"},maxExtraDataSize:{v:32,d:"Maximum size extra data may be after Genesis"}},bi={minimumDifficulty:{v:131072,d:"The minimum that the difficulty may ever be"},difficultyBoundDivisor:{v:2048,d:"The bound divisor of the difficulty, used in the update calculations"},durationLimit:{v:13,d:"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"},epochDuration:{v:3e4,d:"Duration between proof-of-work epochs"},timebombPeriod:{v:1e5,d:"Exponential difficulty timebomb period"},minerReward:{v:"5000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:0,d:"the amount of blocks to delay the difficulty bomb with"}},vi={name:fi,comment:ui,url:mi,status:hi,gasConfig:li,gasPrices:gi,vm:pi,pow:bi},$i="homestead",ki="Homestead hardfork with protocol and network changes",Ii="https://eips.ethereum.org/EIPS/eip-606",Pi="Final",Ei={},Ti={delegatecall:{v:40,d:"Base fee of the DELEGATECALL opcode"}},yi={},Bi={},wi={name:$i,comment:ki,url:Ii,status:Pi,gasConfig:Ei,gasPrices:Ti,vm:yi,pow:Bi},xi="dao",Si="DAO rescue hardfork",Ai="https://eips.ethereum.org/EIPS/eip-779",Hi="Final",Ci={},Li={},_i={},Fi={},Oi={name:xi,comment:Si,url:Ai,status:Hi,gasConfig:Ci,gasPrices:Li,vm:_i,pow:Fi},Di="tangerineWhistle",Ri="Hardfork with gas cost changes for IO-heavy operations",Gi="https://eips.ethereum.org/EIPS/eip-608",Mi="Final",Ni={},qi={sload:{v:200,d:"Once per SLOAD operation"},call:{v:700,d:"Once per CALL operation & message call transaction"},extcodesize:{v:700,d:"Base fee of the EXTCODESIZE opcode"},extcodecopy:{v:700,d:"Base fee of the EXTCODECOPY opcode"},balance:{v:400,d:"Base fee of the BALANCE opcode"},delegatecall:{v:700,d:"Base fee of the DELEGATECALL opcode"},callcode:{v:700,d:"Base fee of the CALLCODE opcode"},selfdestruct:{v:5e3,d:"Base fee of the SELFDESTRUCT opcode"}},zi={},Ui={},ji={name:Di,comment:Ri,url:Gi,status:Mi,gasConfig:Ni,gasPrices:qi,vm:zi,pow:Ui},Ki="spuriousDragon",Vi="HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",Ji="https://eips.ethereum.org/EIPS/eip-607",Yi="Final",Xi={},Wi={expByte:{v:50,d:"Times ceil(log256(exponent)) for the EXP instruction"}},Zi={maxCodeSize:{v:24576,d:"Maximum length of contract code"}},Qi={},ec={name:Ki,comment:Vi,url:Ji,status:Yi,gasConfig:Xi,gasPrices:Wi,vm:Zi,pow:Qi},tc="byzantium",oc="Hardfork with new precompiles, instructions and other protocol changes",sc="https://eips.ethereum.org/EIPS/eip-609",nc="Final",rc={},ac={modexpGquaddivisor:{v:20,d:"Gquaddivisor from modexp precompile for gas calculation"},ecAdd:{v:500,d:"Gas costs for curve addition precompile"},ecMul:{v:4e4,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:1e5,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:8e4,d:"Gas costs regarding curve pairing precompile input length"},revert:{v:0,d:"Base fee of the REVERT opcode"},staticcall:{v:700,d:"Base fee of the STATICCALL opcode"},returndatasize:{v:2,d:"Base fee of the RETURNDATASIZE opcode"},returndatacopy:{v:3,d:"Base fee of the RETURNDATACOPY opcode"}},ic={},cc={minerReward:{v:"3000000000000000000",d:"the amount a miner get rewarded for mining a block"},difficultyBombDelay:{v:3e6,d:"the amount of blocks to delay the difficulty bomb with"}},dc={name:tc,comment:oc,url:sc,status:nc,gasConfig:rc,gasPrices:ac,vm:ic,pow:cc},fc="constantinople",uc="Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",mc="https://eips.ethereum.org/EIPS/eip-1013",hc="Final",lc={},gc={netSstoreNoopGas:{v:200,d:"Once per SSTORE operation if the value doesn't change"},netSstoreInitGas:{v:2e4,d:"Once per SSTORE operation from clean zero"},netSstoreCleanGas:{v:5e3,d:"Once per SSTORE operation from clean non-zero"},netSstoreDirtyGas:{v:200,d:"Once per SSTORE operation from dirty"},netSstoreClearRefund:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},netSstoreResetRefund:{v:4800,d:"Once per SSTORE operation for resetting to the original non-zero value"},netSstoreResetClearRefund:{v:19800,d:"Once per SSTORE operation for resetting to the original zero value"},shl:{v:3,d:"Base fee of the SHL opcode"},shr:{v:3,d:"Base fee of the SHR opcode"},sar:{v:3,d:"Base fee of the SAR opcode"},extcodehash:{v:400,d:"Base fee of the EXTCODEHASH opcode"},create2:{v:32e3,d:"Base fee of the CREATE2 opcode"}},pc={},bc={minerReward:{v:"2000000000000000000",d:"The amount a miner gets rewarded for mining a block"},difficultyBombDelay:{v:5e6,d:"the amount of blocks to delay the difficulty bomb with"}},vc={name:fc,comment:uc,url:mc,status:hc,gasConfig:lc,gasPrices:gc,vm:pc,pow:bc},$c="petersburg",kc="Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",Ic="https://eips.ethereum.org/EIPS/eip-1716",Pc="Final",Ec={},Tc={netSstoreNoopGas:{v:null,d:"Removed along EIP-1283"},netSstoreInitGas:{v:null,d:"Removed along EIP-1283"},netSstoreCleanGas:{v:null,d:"Removed along EIP-1283"},netSstoreDirtyGas:{v:null,d:"Removed along EIP-1283"},netSstoreClearRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetRefund:{v:null,d:"Removed along EIP-1283"},netSstoreResetClearRefund:{v:null,d:"Removed along EIP-1283"}},yc={},Bc={},wc={name:$c,comment:kc,url:Ic,status:Pc,gasConfig:Ec,gasPrices:Tc,vm:yc,pow:Bc},xc="istanbul",Sc="HF targeted for December 2019 following the Constantinople/Petersburg HF",Ac="https://eips.ethereum.org/EIPS/eip-1679",Hc="Final",Cc={},Lc={blake2Round:{v:1,d:"Gas cost per round for the Blake2 F precompile"},ecAdd:{v:150,d:"Gas costs for curve addition precompile"},ecMul:{v:6e3,d:"Gas costs for curve multiplication precompile"},ecPairing:{v:45e3,d:"Base gas costs for curve pairing precompile"},ecPairingWord:{v:34e3,d:"Gas costs regarding curve pairing precompile input length"},txDataNonZero:{v:16,d:"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},sstoreSentryGasEIP2200:{v:2300,d:"Minimum gas required to be present for an SSTORE call, not consumed"},sstoreNoopGasEIP2200:{v:800,d:"Once per SSTORE operation if the value doesn't change"},sstoreDirtyGasEIP2200:{v:800,d:"Once per SSTORE operation if a dirty value is changed"},sstoreInitGasEIP2200:{v:2e4,d:"Once per SSTORE operation from clean zero to non-zero"},sstoreInitRefundEIP2200:{v:19200,d:"Once per SSTORE operation for resetting to the original zero value"},sstoreCleanGasEIP2200:{v:5e3,d:"Once per SSTORE operation from clean non-zero to something else"},sstoreCleanRefundEIP2200:{v:4200,d:"Once per SSTORE operation for resetting to the original non-zero value"},sstoreClearRefundEIP2200:{v:15e3,d:"Once per SSTORE operation for clearing an originally existing storage slot"},balance:{v:700,d:"Base fee of the BALANCE opcode"},extcodehash:{v:700,d:"Base fee of the EXTCODEHASH opcode"},chainid:{v:2,d:"Base fee of the CHAINID opcode"},selfbalance:{v:5,d:"Base fee of the SELFBALANCE opcode"},sload:{v:800,d:"Base fee of the SLOAD opcode"}},_c={},Fc={},Oc={name:xc,comment:Sc,url:Ac,status:Hc,gasConfig:Cc,gasPrices:Lc,vm:_c,pow:Fc},Dc="muirGlacier",Rc="HF to delay the difficulty bomb",Gc="https://eips.ethereum.org/EIPS/eip-2384",Mc="Final",Nc={},qc={},zc={},Uc={difficultyBombDelay:{v:9e6,d:"the amount of blocks to delay the difficulty bomb with"}},jc={name:Dc,comment:Rc,url:Gc,status:Mc,gasConfig:Nc,gasPrices:qc,vm:zc,pow:Uc},Kc="berlin",Vc="HF targeted for July 2020 following the Muir Glacier HF",Jc="https://eips.ethereum.org/EIPS/eip-2070",Yc="Final",Xc=[2565,2929,2718,2930],Wc={name:Kc,comment:Vc,url:Jc,status:Yc,eips:Xc},Zc="london",Qc="HF targeted for July 2021 following the Berlin fork",ed="https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",td="Final",od=[1559,3198,3529,3541],sd={name:Zc,comment:Qc,url:ed,status:td,eips:od},nd="shanghai",rd="Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",ad="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",id="Final",cd=[3651,3855,3860,4895],dd={name:nd,comment:rd,url:ad,status:id,eips:cd},fd="arrowGlacier",ud="HF to delay the difficulty bomb",md="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",hd="Final",ld=[4345],gd={},pd={},bd={},vd={},$d={name:fd,comment:ud,url:md,status:hd,eips:ld,gasConfig:gd,gasPrices:pd,vm:bd,pow:vd},kd="grayGlacier",Id="Delaying the difficulty bomb to Mid September 2022",Pd="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",Ed="Draft",Td=[5133],yd={},Bd={},wd={},xd={},Sd={name:kd,comment:Id,url:Pd,status:Ed,eips:Td,gasConfig:yd,gasPrices:Bd,vm:wd,pow:xd},Ad="mergeForkIdTransition",Hd="Pre-merge hardfork to fork off non-upgraded clients",Cd="https://eips.ethereum.org/EIPS/eip-3675",Ld="Draft",_d=[],Fd={name:Ad,comment:Hd,url:Cd,status:Ld,eips:_d},Od="merge",Dd="Hardfork to upgrade the consensus mechanism to Proof-of-Stake",Rd="https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",Gd="Final",Md={type:"pos",algorithm:"casper",casper:{}},Nd=[3675,4399],qd={name:Od,comment:Dd,url:Rd,status:Gd,consensus:Md,eips:Nd},zd="shardingFork",Ud="Internal hardfork to test proto-danksharding (do not use in production)",jd="https://eips.ethereum.org/EIPS/eip-4844",Kd="Experimental",Vd=[4844],Jd={name:zd,comment:Ud,url:jd,status:Kd,eips:Vd};Object.defineProperty(fe,"__esModule",{value:!0});fe.hardforks=void 0;fe.hardforks={chainstart:vi,homestead:wi,dao:Oi,tangerineWhistle:ji,spuriousDragon:ec,byzantium:dc,constantinople:vc,petersburg:wc,istanbul:Oc,muirGlacier:jc,berlin:Wc,london:sd,shanghai:dd,arrowGlacier:$d,grayGlacier:Sd,mergeForkIdTransition:Fd,merge:qd,shardingFork:Jd};var Y={};Object.defineProperty(Y,"__esModule",{value:!0});Y.parseGethGenesis=void 0;const re=C,B=de;function Yd(i){return!i||i==="0x0"?"0x0000000000000000":(0,re.isHexPrefixed)(i)?"0x"+(0,re.stripHexPrefix)(i).padStart(16,"0"):"0x"+i.padStart(16,"0")}function Xd(i,e=!0){const{name:o,config:t,difficulty:s,mixHash:n,gasLimit:a,coinbase:r,baseFeePerGas:d}=i;let{extraData:m,timestamp:u,nonce:h}=i;const P=Number(u),{chainId:y}=t;if(m===""&&(m="0x"),(0,re.isHexPrefixed)(u)||(u=(0,re.intToHex)(parseInt(u))),h.length!==18&&(h=Yd(h)),t.eip155Block!==t.eip158Block)throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");const E={name:o,chainId:y,networkId:y,genesis:{timestamp:u,gasLimit:parseInt(a),difficulty:parseInt(s),nonce:h,extraData:m,mixHash:n,coinbase:r,baseFeePerGas:d},hardfork:void 0,hardforks:[],bootstrapNodes:[],consensus:t.clique!==void 0?{type:"poa",algorithm:"clique",clique:{period:t.clique.period??t.clique.blockperiodseconds,epoch:t.clique.epoch??t.clique.epochlength}}:{type:"pow",algorithm:"ethash",ethash:{}}},H={[B.Hardfork.Homestead]:{name:"homesteadBlock"},[B.Hardfork.Dao]:{name:"daoForkBlock"},[B.Hardfork.TangerineWhistle]:{name:"eip150Block"},[B.Hardfork.SpuriousDragon]:{name:"eip155Block"},[B.Hardfork.Byzantium]:{name:"byzantiumBlock"},[B.Hardfork.Constantinople]:{name:"constantinopleBlock"},[B.Hardfork.Petersburg]:{name:"petersburgBlock"},[B.Hardfork.Istanbul]:{name:"istanbulBlock"},[B.Hardfork.MuirGlacier]:{name:"muirGlacierBlock"},[B.Hardfork.Berlin]:{name:"berlinBlock"},[B.Hardfork.London]:{name:"londonBlock"},[B.Hardfork.MergeForkIdTransition]:{name:"mergeForkBlock",postMerge:e},[B.Hardfork.Shanghai]:{name:"shanghaiTime",postMerge:!0,isTimestamp:!0},[B.Hardfork.ShardingForkDev]:{name:"shardingForkTime",postMerge:!0,isTimestamp:!0}},L=Object.keys(H).reduce((k,A)=>(k[H[A].name]=A,k),{}),j=Object.keys(t).filter(k=>L[k]!==void 0&&t[k]!==void 0&&t[k]!==null);if(E.hardforks=j.map(k=>({name:L[k],block:H[L[k]].isTimestamp===!0||typeof t[k]!="number"?null:t[k],timestamp:H[L[k]].isTimestamp===!0&&typeof t[k]=="number"?t[k]:void 0})).filter(k=>k.block!==null||k.timestamp!==void 0),E.hardforks.sort(function(k,A){return(k.block??1/0)-(A.block??1/0)}),E.hardforks.sort(function(k,A){return(k.timestamp??P)-(A.timestamp??P)}),t.terminalTotalDifficulty!==void 0){const k={name:B.Hardfork.Merge,ttd:t.terminalTotalDifficulty,block:null},A=E.hardforks.findIndex(he=>{var Q;return((Q=H[he.name])==null?void 0:Q.postMerge)===!0});A!==-1?E.hardforks.splice(A,0,k):E.hardforks.push(k)}const _=E.hardforks.length>0?E.hardforks.slice(-1)[0]:void 0;return E.hardfork=_==null?void 0:_.name,E.hardforks.unshift({name:B.Hardfork.Chainstart,block:0}),E}function Wd(i,e,o){try{if(["config","difficulty","gasLimit","alloc"].some(t=>!(t in i)))throw new Error("Invalid format, expected geth genesis fields missing");return e!==void 0&&(i.name=e),Xd(i,o)}catch(t){throw new Error(`Error parsing parameters file: ${t.message}`)}}Y.parseGethGenesis=Wd;Object.defineProperty(ie,"__esModule",{value:!0});ie.Common=void 0;const x=C,Zd=_e,Qd=De,ef=We,tf=dt,of=It,sf=Lt,nf=jt,D=ce,I=de,rf=fe,af=Y;class S extends Qd.EventEmitter{constructor(e){super(),this._eips=[],this._customChains=e.customChains??[],this._chainParams=this.setChain(e.chain),this.DEFAULT_HARDFORK=this._chainParams.defaultHardfork??I.Hardfork.Merge,this.HARDFORK_CHANGES=this.hardforks().map(o=>[o.name,rf.hardforks[o.name]]),this._hardfork=this.DEFAULT_HARDFORK,e.hardfork!==void 0&&this.setHardfork(e.hardfork),e.eips&&this.setEIPs(e.eips)}static custom(e,o={}){const t=o.baseChain??"mainnet",s={...S._getChainParams(t)};if(s.name="custom-chain",typeof e!="string")return new S({chain:{...s,...e},...o});if(e===I.CustomChain.PolygonMainnet)return S.custom({name:I.CustomChain.PolygonMainnet,chainId:137,networkId:137},o);if(e===I.CustomChain.PolygonMumbai)return S.custom({name:I.CustomChain.PolygonMumbai,chainId:80001,networkId:80001},o);if(e===I.CustomChain.ArbitrumRinkebyTestnet)return S.custom({name:I.CustomChain.ArbitrumRinkebyTestnet,chainId:421611,networkId:421611},o);if(e===I.CustomChain.ArbitrumOne)return S.custom({name:I.CustomChain.ArbitrumOne,chainId:42161,networkId:42161},o);if(e===I.CustomChain.xDaiChain)return S.custom({name:I.CustomChain.xDaiChain,chainId:100,networkId:100},o);if(e===I.CustomChain.OptimisticKovan)return S.custom({name:I.CustomChain.OptimisticKovan,chainId:69,networkId:69},{hardfork:I.Hardfork.Berlin,...o});if(e===I.CustomChain.OptimisticEthereum)return S.custom({name:I.CustomChain.OptimisticEthereum,chainId:10,networkId:10},{hardfork:I.Hardfork.Berlin,...o});throw new Error(`Custom chain ${e} not supported`)}static fromGethGenesis(e,{chain:o,eips:t,genesisHash:s,hardfork:n,mergeForkIdPostMerge:a}){const r=(0,af.parseGethGenesis)(e,o,a),d=new S({chain:r.name??"custom",customChains:[r],eips:t,hardfork:n??r.hardfork});return s!==void 0&&d.setForkHashes(s),d}static isSupportedChainId(e){return!!this._getInitializedChains().names[e.toString()]}static _getChainParams(e,o){const t=this._getInitializedChains(o);if(typeof e=="number"||typeof e=="bigint"){if(e=e.toString(),t.names[e]){const s=t.names[e];return t[s]}throw new Error(`Chain with ID ${e} not supported`)}if(t[e]!==void 0)return t[e];throw new Error(`Chain with name ${e} not supported`)}setChain(e){if(typeof e=="number"||typeof e=="bigint"||typeof e=="string")this._chainParams=S._getChainParams(e,this._customChains);else if(typeof e=="object"){if(this._customChains.length>0)throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");const o=["networkId","genesis","hardforks","bootstrapNodes"];for(const t of o)if(!(t in e))throw new Error(`Missing required chain parameter: ${t}`);this._chainParams=e}else throw new Error("Wrong input format");for(const o of this.hardforks())if(o.block===void 0)throw new Error("Hardfork cannot have undefined block number");return this._chainParams}setHardfork(e){let o=!1;for(const t of this.HARDFORK_CHANGES)t[0]===e&&(this._hardfork!==e&&(this._hardfork=e,this.emit("hardforkChanged",e)),o=!0);if(!o)throw new Error(`Hardfork with name ${e} not supported`)}getHardforkByBlockNumber(e,o,t){e=(0,x.toType)(e,x.TypeOutput.BigInt),o=(0,x.toType)(o,x.TypeOutput.BigInt),t=(0,x.toType)(t,x.TypeOutput.Number);const s=this.hardforks().filter(u=>u.block!==null||u.ttd!==null&&u.ttd!==void 0||u.timestamp!==void 0),n=s.findIndex(u=>u.ttd!==null&&u.ttd!==void 0);if(s.slice(n+1).findIndex(u=>u.ttd!==null&&u.ttd!==void 0)>=0)throw Error("More than one merge hardforks found with ttd specified");let r=s.findIndex(u=>u.block!==null&&u.block>e||t!==void 0&&Number(u.timestamp)>t);if(r===-1)r=s.length;else if(r===0)throw Error("Must have at least one hardfork at block 0");if(t===void 0){const u=s.slice(0,r).reverse().findIndex(h=>h.block!==null||h.ttd!==void 0);r=r-u}if(r=r-1,s[r].block===null&&s[r].timestamp===void 0)(o==null||BigInt(s[r].ttd)>o)&&(r-=1);else if(n>=0&&o!==void 0&&o!==null){if(r>=n&&BigInt(s[n].ttd)>o)throw Error("Maximum HF determined by total difficulty is lower than the block number HF");if(r<n&&BigInt(s[n].ttd)<=o)throw Error("HF determined by block number is lower than the minimum total difficulty HF")}const d=r;for(;r<s.length-1&&!(s[r].block!==s[r+1].block||s[r].timestamp!==s[r+1].timestamp);r++);if(t){if(s.slice(0,d).reduce((P,y)=>Math.max(Number(y.timestamp??"0"),P),0)>t)throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");if(s.slice(r+1).reduce((P,y)=>Math.min(Number(y.timestamp??t),P),t)<t)throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")}return s[r].name}setHardforkByBlockNumber(e,o,t){const s=this.getHardforkByBlockNumber(e,o,t);return this.setHardfork(s),s}_getHardfork(e){const o=this.hardforks();for(const t of o)if(t.name===e)return t;return null}setEIPs(e=[]){for(const o of e){if(!(o in D.EIPs))throw new Error(`${o} not supported`);const t=this.gteHardfork(D.EIPs[o].minimumHardfork);if(!t)throw new Error(`${o} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${t}`);if(D.EIPs[o].requiredEIPs!==void 0){for(const s of D.EIPs[o].requiredEIPs)if(!(e.includes(s)||this.isActivatedEIP(s)))throw new Error(`${o} requires EIP ${s}, but is not included in the EIP list`)}}this._eips=e}param(e,o){let t;for(const s of this._eips)if(t=this.paramByEIP(e,o,s),t!==void 0)return t;return this.paramByHardfork(e,o,this._hardfork)}paramByHardfork(e,o,t){let s=null;for(const n of this.HARDFORK_CHANGES){if("eips"in n[1]){const a=n[1].eips;for(const r of a){const d=this.paramByEIP(e,o,r);s=typeof d=="bigint"?d:s}}else{if(n[1][e]===void 0)throw new Error(`Topic ${e} not defined`);n[1][e][o]!==void 0&&(s=n[1][e][o].v)}if(n[0]===t)break}return BigInt(s??0)}paramByEIP(e,o,t){if(!(t in D.EIPs))throw new Error(`${t} not supported`);const s=D.EIPs[t];if(!(e in s))throw new Error(`Topic ${e} not defined`);if(s[e][o]===void 0)return;const n=s[e][o].v;return BigInt(n)}paramByBlock(e,o,t,s,n){const a=this.getHardforkByBlockNumber(t,s,n);return this.paramByHardfork(e,o,a)}isActivatedEIP(e){if(this.eips().includes(e))return!0;for(const o of this.HARDFORK_CHANGES){const t=o[1];if(this.gteHardfork(t.name)&&"eips"in t&&t.eips.includes(e))return!0}return!1}hardforkIsActiveOnBlock(e,o){o=(0,x.toType)(o,x.TypeOutput.BigInt),e=e??this._hardfork;const t=this.hardforkBlock(e);return typeof t=="bigint"&&t!==BigInt(0)&&o>=t}activeOnBlock(e){return this.hardforkIsActiveOnBlock(null,e)}hardforkGteHardfork(e,o){e=e??this._hardfork;const t=this.hardforks();let s=-1,n=-1,a=0;for(const r of t)r.name===e&&(s=a),r.name===o&&(n=a),a+=1;return s>=n&&n!==-1}gteHardfork(e){return this.hardforkGteHardfork(null,e)}hardforkBlock(e){var t;e=e??this._hardfork;const o=(t=this._getHardfork(e))==null?void 0:t.block;return o==null?null:BigInt(o)}hardforkTimestamp(e){var t;e=e??this._hardfork;const o=(t=this._getHardfork(e))==null?void 0:t.timestamp;return o==null?null:BigInt(o)}eipBlock(e){for(const o of this.HARDFORK_CHANGES){const t=o[1];if("eips"in t&&t.eips.includes(e))return this.hardforkBlock(o[0])}return null}hardforkTTD(e){var t;e=e??this._hardfork;const o=(t=this._getHardfork(e))==null?void 0:t.ttd;return o==null?null:BigInt(o)}isHardforkBlock(e,o){e=(0,x.toType)(e,x.TypeOutput.BigInt),o=o??this._hardfork;const t=this.hardforkBlock(o);return typeof t=="bigint"&&t!==BigInt(0)?t===e:!1}nextHardforkBlockOrTimestamp(e){e=e??this._hardfork;const o=this.hardforks();let t=o.findIndex(r=>r.name===e);if(e===I.Hardfork.Merge&&(t-=1),t<0)return null;let s=o[t].timestamp??o[t].block;s=s!=null?Number(s):null;const n=o.slice(t+1).find(r=>{let d=r.timestamp??r.block;return d=d!=null?Number(d):null,r.name!==I.Hardfork.Merge&&d!==null&&d!==void 0&&d!==s});if(n===void 0)return null;const a=n.timestamp??n.block;return a==null?null:BigInt(a)}nextHardforkBlock(e){e=e??this._hardfork;let o=this.hardforkBlock(e);if(o===null&&e===I.Hardfork.Merge){const s=this.hardforks(),n=s.findIndex(a=>a.ttd!==null&&a.ttd!==void 0);if(n<0)throw Error("Merge hardfork should have been found");o=this.hardforkBlock(s[n-1].name)}return o===null?null:this.hardforks().reduce((s,n)=>{const a=BigInt(n.block===null||n.ttd!==void 0&&n.ttd!==null?0:n.block);return a>o&&s===null?a:s},null)}isNextHardforkBlock(e,o){e=(0,x.toType)(e,x.TypeOutput.BigInt),o=o??this._hardfork;const t=this.nextHardforkBlock(o);return t===null?!1:t===e}_calcForkHash(e,o){let t=Buffer.alloc(0),s=0;for(const r of this.hardforks()){const{block:d,timestamp:m,name:u}=r;let h=m??d;if(h=h!==null?Number(h):null,typeof h=="number"&&h!==0&&h!==s&&u!==I.Hardfork.Merge){const P=Buffer.from(h.toString(16).padStart(16,"0"),"hex");t=Buffer.concat([t,P]),s=h}if(r.name===e)break}const n=Buffer.concat([o,t]);return`0x${(0,x.intToBuffer)((0,Zd.buf)(n)>>>0).toString("hex")}`}forkHash(e,o){e=e??this._hardfork;const t=this._getHardfork(e);if(t===null||(t==null?void 0:t.block)===null&&(t==null?void 0:t.timestamp)===void 0&&(t==null?void 0:t.ttd)===void 0){const s="No fork hash calculation possible for future hardfork";throw new Error(s)}if((t==null?void 0:t.forkHash)!==null&&(t==null?void 0:t.forkHash)!==void 0)return t.forkHash;if(!o)throw new Error("genesisHash required for forkHash calculation");return this._calcForkHash(e,o)}hardforkForForkHash(e){const o=this.hardforks().filter(t=>t.forkHash===e);return o.length>=1?o[o.length-1]:null}setForkHashes(e){for(const o of this.hardforks()){const t=o.timestamp??o.block;(o.forkHash===null||o.forkHash===void 0)&&(t!=null||typeof o.ttd<"u")&&(o.forkHash=this.forkHash(o.name,e))}}genesis(){return this._chainParams.genesis}hardforks(){return this._chainParams.hardforks}bootstrapNodes(){return this._chainParams.bootstrapNodes}dnsNetworks(){return this._chainParams.dnsNetworks}hardfork(){return this._hardfork}chainId(){return BigInt(this._chainParams.chainId)}chainName(){return this._chainParams.name}networkId(){return BigInt(this._chainParams.networkId)}eips(){return this._eips}consensusType(){const e=this.hardfork();let o;for(const t of this.HARDFORK_CHANGES)if("consensus"in t[1]&&(o=t[1].consensus.type),t[0]===e)break;return o??this._chainParams.consensus.type}consensusAlgorithm(){const e=this.hardfork();let o;for(const t of this.HARDFORK_CHANGES)if("consensus"in t[1]&&(o=t[1].consensus.algorithm),t[0]===e)break;return o??this._chainParams.consensus.algorithm}consensusConfig(){const e=this.hardfork();let o;for(const t of this.HARDFORK_CHANGES)if("consensus"in t[1]&&(o=t[1].consensus[t[1].consensus.algorithm]),t[0]===e)break;return o??this._chainParams.consensus[this.consensusAlgorithm()]??{}}copy(){const e=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return e.removeAllListeners(),e}static _getInitializedChains(e){const o={};for(const[s,n]of Object.entries(I.Chain))o[n]=s.toLowerCase();const t={mainnet:tf,ropsten:sf,rinkeby:of,goerli:ef,sepolia:nf};if(e)for(const s of e){const{name:n}=s;o[s.chainId.toString()]=n,t[n]=s}return t.names=o,t}}ie.Common=S;var Fe={};Object.defineProperty(Fe,"__esModule",{value:!0});(function(i){var e=F&&F.__createBinding||(Object.create?function(t,s,n,a){a===void 0&&(a=n);var r=Object.getOwnPropertyDescriptor(s,n);(!r||("get"in r?!s.__esModule:r.writable||r.configurable))&&(r={enumerable:!0,get:function(){return s[n]}}),Object.defineProperty(t,a,r)}:function(t,s,n,a){a===void 0&&(a=n),t[a]=s[n]}),o=F&&F.__exportStar||function(t,s){for(var n in t)n!=="default"&&!Object.prototype.hasOwnProperty.call(s,n)&&e(s,t,n)};Object.defineProperty(i,"__esModule",{value:!0}),o(ie,i),o(de,i),o(Fe,i),o(Y,i)})(Le);var X={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.isAccessList=i.isAccessListBuffer=i.Capability=void 0,function(t){t[t.EIP155ReplayProtection=155]="EIP155ReplayProtection",t[t.EIP1559FeeMarket=1559]="EIP1559FeeMarket",t[t.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",t[t.EIP2930AccessLists=2930]="EIP2930AccessLists"}(i.Capability||(i.Capability={}));function e(t){if(t.length===0)return!0;const s=t[0];return!!Array.isArray(s)}i.isAccessListBuffer=e;function o(t){return!e(t)}i.isAccessList=o})(X);var O={};Object.defineProperty(O,"__esModule",{value:!0});O.AccessLists=O.checkMaxInitCodeSize=void 0;const R=C,cf=X;function df(i,e){const o=i.param("vm","maxInitCodeSize");if(o&&BigInt(e)>o)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${i.param("vm","maxInitCodeSize")}`)}O.checkMaxInitCodeSize=df;class ff{static getAccessListData(e){let o,t;if((0,cf.isAccessList)(e)){o=e;const s=[];for(let n=0;n<e.length;n++){const a=e[n],r=(0,R.toBuffer)(a.address),d=[];for(let m=0;m<a.storageKeys.length;m++)d.push((0,R.toBuffer)(a.storageKeys[m]));s.push([r,d])}t=s}else{t=e??[];const s=[];for(let n=0;n<t.length;n++){const a=t[n],r=(0,R.bufferToHex)(a[0]),d=[];for(let u=0;u<a[1].length;u++)d.push((0,R.bufferToHex)(a[1][u]));const m={address:r,storageKeys:d};s.push(m)}o=s}return{AccessListJSON:o,accessList:t}}static verifyAccessList(e){for(let o=0;o<e.length;o++){const t=e[o],s=t[0],n=t[1];if(t[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(s.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let a=0;a<n.length;a++)if(n[a].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const o=[];for(let t=0;t<e.length;t++){const s=e[t],n={address:"0x"+(0,R.setLengthLeft)(s[0],20).toString("hex"),storageKeys:[]},a=s[1];for(let r=0;r<a.length;r++){const d=a[r];n.storageKeys.push("0x"+(0,R.setLengthLeft)(d,32).toString("hex"))}o.push(n)}return o}static getDataFeeEIP2930(e,o){const t=o.param("gasPrices","accessListStorageKeyCost"),s=o.param("gasPrices","accessListAddressCost");let n=0;for(let r=0;r<e.length;r++){const m=e[r][1];n+=m.length}return e.length*Number(s)+n*Number(t)}}O.AccessLists=ff;Object.defineProperty(U,"__esModule",{value:!0});U.BaseTransaction=void 0;const G=Le,v=C,ge=X,uf=O;class mf{constructor(e,o){this.cache={hash:void 0,dataFee:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=G.Chain.Mainnet,this.DEFAULT_HARDFORK=G.Hardfork.Merge;const{nonce:t,gasLimit:s,to:n,value:a,data:r,v:d,r:m,s:u,type:h}=e;this._type=Number((0,v.bufferToBigInt)((0,v.toBuffer)(h))),this.txOptions=o;const P=(0,v.toBuffer)(n===""?"0x":n),y=(0,v.toBuffer)(d===""?"0x":d),E=(0,v.toBuffer)(m===""?"0x":m),H=(0,v.toBuffer)(u===""?"0x":u);this.nonce=(0,v.bufferToBigInt)((0,v.toBuffer)(t===""?"0x":t)),this.gasLimit=(0,v.bufferToBigInt)((0,v.toBuffer)(s===""?"0x":s)),this.to=P.length>0?new v.Address(P):void 0,this.value=(0,v.bufferToBigInt)((0,v.toBuffer)(a===""?"0x":a)),this.data=(0,v.toBuffer)(r===""?"0x":r),this.v=y.length>0?(0,v.bufferToBigInt)(y):void 0,this.r=E.length>0?(0,v.bufferToBigInt)(E):void 0,this.s=H.length>0?(0,v.bufferToBigInt)(H):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const L=this.to===void 0||this.to===null,j=o.allowUnlimitedInitCodeSize??!1,_=o.common??this._getCommon();L&&_.isActivatedEIP(3860)&&j===!1&&(0,uf.checkMaxInitCodeSize)(_,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}validate(e=!1){const o=[];return this.getBaseFee()>this.gasLimit&&o.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),this.isSigned()&&!this.verifySignature()&&o.push("Invalid Signature"),e?o:o.length===0}_validateYParity(){const{v:e}=this;if(e!==void 0&&e!==BigInt(0)&&e!==BigInt(1)){const o=this._errorMsg("The y-parity of the transaction should either be 0 or 1");throw new Error(o)}}_validateHighS(){const{s:e}=this;if(this.common.gteHardfork("homestead")&&e!==void 0&&e>v.SECP256K1_ORDER_DIV_2){const o=this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(o)}}getBaseFee(){const e=this.common.param("gasPrices","tx");let o=this.getDataFee();if(e&&(o+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const t=this.common.param("gasPrices","txCreation");t&&(o+=t)}return o}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),o=this.common.param("gasPrices","txDataNonZero");let t=BigInt(0);for(let s=0;s<this.data.length;s++)this.data[s]===0?t+=e:t+=o;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const s=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*s;t+=n}return t}toCreationAddress(){return this.to===void 0||this.to.buf.length===0}isSigned(){const{v:e,r:o,s:t}=this;return!(e===void 0||o===void 0||t===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return(0,v.unpadBuffer)(e).length!==0}catch{return!1}}getSenderAddress(){return new v.Address((0,v.publicToAddress)(this.getSenderPublicKey()))}sign(e){if(e.length!==32){const d=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(d)}let o=!1;this.type===0&&this.common.gteHardfork("spuriousDragon")&&!this.supports(ge.Capability.EIP155ReplayProtection)&&(this.activeCapabilities.push(ge.Capability.EIP155ReplayProtection),o=!0);const t=this.getMessageToSign(!0),{v:s,r:n,s:a}=(0,v.ecsign)(t,e),r=this._processSignature(s,n,a);if(o){const d=this.activeCapabilities.indexOf(ge.Capability.EIP155ReplayProtection);d>-1&&this.activeCapabilities.splice(d,1)}return r}_getCommon(e,o){if(o!==void 0){const t=(0,v.bufferToBigInt)((0,v.toBuffer)(o));if(e){if(e.chainId()!==t){const s=this._errorMsg("The chain ID does not match the chain ID of Common");throw new Error(s)}return e.copy()}else return G.Common.isSupportedChainId(t)?new G.Common({chain:t,hardfork:this.DEFAULT_HARDFORK}):G.Common.custom({name:"custom-chain",networkId:t,chainId:t},{baseChain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}else return(e==null?void 0:e.copy())??new G.Common({chain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}_validateCannotExceedMaxInteger(e,o=256,t=!1){for(const[s,n]of Object.entries(e))switch(o){case 64:if(t){if(n!==void 0&&n>=v.MAX_UINT64){const a=this._errorMsg(`${s} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(a)}}else if(n!==void 0&&n>v.MAX_UINT64){const a=this._errorMsg(`${s} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(a)}break;case 256:if(t){if(n!==void 0&&n>=v.MAX_INTEGER){const a=this._errorMsg(`${s} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(a)}}else if(n!==void 0&&n>v.MAX_INTEGER){const a=this._errorMsg(`${s} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(a)}break;default:{const a=this._errorMsg("unimplemented bits value");throw new Error(a)}}}static _validateNotArray(e){const o=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[t,s]of Object.entries(e))if(o.includes(t)&&Array.isArray(s))throw new Error(`${t} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?(0,v.bufferToHex)(this.hash()):"not available (unsigned)"}catch{e="error"}let o="";try{o=this.isSigned().toString()}catch{e="error"}let t="";try{t=this.common.hardfork()}catch{t="error"}let s=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return s+=`signed=${o} hf=${t}`,s}}U.BaseTransaction=mf;Object.defineProperty(J,"__esModule",{value:!0});J.FeeMarketEIP1559Transaction=void 0;const pe=Te,g=C,be=ye,we=U,ee=O,Pe=2,ve=Buffer.from(Pe.toString(16).padStart(2,"0"),"hex");class q extends we.BaseTransaction{constructor(e,o={}){super({...e,type:Pe},o),this.DEFAULT_HARDFORK="london";const{chainId:t,accessList:s,maxFeePerGas:n,maxPriorityFeePerGas:a}=e;if(this.common=this._getCommon(o.common,t),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const r=ee.AccessLists.getAccessListData(s??[]);if(this.accessList=r.accessList,this.AccessListJSON=r.AccessListJSON,ee.AccessLists.verifyAccessList(this.accessList),this.maxFeePerGas=(0,g.bufferToBigInt)((0,g.toBuffer)(n===""?"0x":n)),this.maxPriorityFeePerGas=(0,g.bufferToBigInt)((0,g.toBuffer)(a===""?"0x":a)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),we.BaseTransaction._validateNotArray(e),this.gasLimit*this.maxFeePerGas>g.MAX_INTEGER){const m=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(m)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const m=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(m)}this._validateYParity(),this._validateHighS(),((o==null?void 0:o.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,o={}){return new q(e,o)}static fromSerializedTx(e,o={}){if(!e.slice(0,1).equals(ve))throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${Pe}, received: ${e.slice(0,1).toString("hex")}`);const t=(0,g.arrToBufArr)(pe.RLP.decode(e.slice(1)));if(!Array.isArray(t))throw new Error("Invalid serialized tx input: must be array");return q.fromValuesArray(t,o)}static fromValuesArray(e,o={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[t,s,n,a,r,d,m,u,h,P,y,E]=e;return this._validateNotArray({chainId:t,v:P}),(0,g.validateNoLeadingZeroes)({nonce:s,maxPriorityFeePerGas:n,maxFeePerGas:a,gasLimit:r,value:m,v:P,r:y,s:E}),new q({chainId:(0,g.bufferToBigInt)(t),nonce:s,maxPriorityFeePerGas:n,maxFeePerGas:a,gasLimit:r,to:d,value:m,data:u,accessList:h??[],v:P!==void 0?(0,g.bufferToBigInt)(P):void 0,r:y,s:E},o)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(ee.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(e=BigInt(0)){const o=this.maxPriorityFeePerGas,t=this.maxFeePerGas-e,n=(o<t?o:t)+e;return this.gasLimit*n+this.value}raw(){return[(0,g.bigIntToUnpaddedBuffer)(this.chainId),(0,g.bigIntToUnpaddedBuffer)(this.nonce),(0,g.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),(0,g.bigIntToUnpaddedBuffer)(this.maxFeePerGas),(0,g.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:Buffer.from([]),(0,g.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,this.v!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.v):Buffer.from([]),this.r!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.r):Buffer.from([]),this.s!==void 0?(0,g.bigIntToUnpaddedBuffer)(this.s):Buffer.from([])]}serialize(){const e=this.raw();return Buffer.concat([ve,Buffer.from(pe.RLP.encode((0,g.bufArrToArr)(e)))])}getMessageToSign(e=!0){const o=this.raw().slice(0,9),t=Buffer.concat([ve,Buffer.from(pe.RLP.encode((0,g.bufArrToArr)(o)))]);return e?Buffer.from((0,be.keccak256)(t)):t}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=Buffer.from((0,be.keccak256)(this.serialize()))),this.cache.hash):Buffer.from((0,be.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:o,r:t,s}=this;this._validateHighS();try{return(0,g.ecrecover)(e,o+BigInt(27),(0,g.bigIntToUnpaddedBuffer)(t),(0,g.bigIntToUnpaddedBuffer)(s))}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,o,t){const s={...this.txOptions,common:this.common};return q.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,g.bufferToBigInt)(o),s:(0,g.bufferToBigInt)(t)},s)}toJSON(){const e=ee.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,g.bigIntToHex)(this.chainId),nonce:(0,g.bigIntToHex)(this.nonce),maxPriorityFeePerGas:(0,g.bigIntToHex)(this.maxPriorityFeePerGas),maxFeePerGas:(0,g.bigIntToHex)(this.maxFeePerGas),gasLimit:(0,g.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,g.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:this.v!==void 0?(0,g.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,g.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,g.bigIntToHex)(this.s):void 0}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}J.FeeMarketEIP1559Transaction=q;var W={};Object.defineProperty(W,"__esModule",{value:!0});W.AccessListEIP2930Transaction=void 0;const $e=Te,p=C,ke=ye,xe=U,te=O,Ee=1,Ie=Buffer.from(Ee.toString(16).padStart(2,"0"),"hex");class z extends xe.BaseTransaction{constructor(e,o={}){super({...e,type:Ee},o),this.DEFAULT_HARDFORK="berlin";const{chainId:t,accessList:s,gasPrice:n}=e;if(this.common=this._getCommon(o.common,t),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const a=te.AccessLists.getAccessListData(s??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,te.AccessLists.verifyAccessList(this.accessList),this.gasPrice=(0,p.bufferToBigInt)((0,p.toBuffer)(n===""?"0x":n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),xe.BaseTransaction._validateNotArray(e),this.gasPrice*this.gasLimit>p.MAX_INTEGER){const d=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(d)}this._validateYParity(),this._validateHighS(),((o==null?void 0:o.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,o={}){return new z(e,o)}static fromSerializedTx(e,o={}){if(!e.slice(0,1).equals(Ie))throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${Ee}, received: ${e.slice(0,1).toString("hex")}`);const t=(0,p.arrToBufArr)($e.RLP.decode(Uint8Array.from(e.slice(1))));if(!Array.isArray(t))throw new Error("Invalid serialized tx input: must be array");return z.fromValuesArray(t,o)}static fromValuesArray(e,o={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[t,s,n,a,r,d,m,u,h,P,y]=e;this._validateNotArray({chainId:t,v:h}),(0,p.validateNoLeadingZeroes)({nonce:s,gasPrice:n,gasLimit:a,value:d,v:h,r:P,s:y});const E=[];return new z({chainId:(0,p.bufferToBigInt)(t),nonce:s,gasPrice:n,gasLimit:a,to:r,value:d,data:m,accessList:u??E,v:h!==void 0?(0,p.bufferToBigInt)(h):void 0,r:P,s:y},o)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(te.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[(0,p.bigIntToUnpaddedBuffer)(this.chainId),(0,p.bigIntToUnpaddedBuffer)(this.nonce),(0,p.bigIntToUnpaddedBuffer)(this.gasPrice),(0,p.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:Buffer.from([]),(0,p.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,this.v!==void 0?(0,p.bigIntToUnpaddedBuffer)(this.v):Buffer.from([]),this.r!==void 0?(0,p.bigIntToUnpaddedBuffer)(this.r):Buffer.from([]),this.s!==void 0?(0,p.bigIntToUnpaddedBuffer)(this.s):Buffer.from([])]}serialize(){const e=this.raw();return Buffer.concat([Ie,Buffer.from($e.RLP.encode((0,p.bufArrToArr)(e)))])}getMessageToSign(e=!0){const o=this.raw().slice(0,8),t=Buffer.concat([Ie,Buffer.from($e.RLP.encode((0,p.bufArrToArr)(o)))]);return e?Buffer.from((0,ke.keccak256)(t)):t}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=Buffer.from((0,ke.keccak256)(this.serialize()))),this.cache.hash):Buffer.from((0,ke.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const n=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(n)}const e=this.getMessageToVerifySignature(),{v:o,r:t,s}=this;this._validateHighS();try{return(0,p.ecrecover)(e,o+BigInt(27),(0,p.bigIntToUnpaddedBuffer)(t),(0,p.bigIntToUnpaddedBuffer)(s))}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,o,t){const s={...this.txOptions,common:this.common};return z.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,p.bufferToBigInt)(o),s:(0,p.bufferToBigInt)(t)},s)}toJSON(){const e=te.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,p.bigIntToHex)(this.chainId),nonce:(0,p.bigIntToHex)(this.nonce),gasPrice:(0,p.bigIntToHex)(this.gasPrice),gasLimit:(0,p.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,p.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:this.v!==void 0?(0,p.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,p.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,p.bigIntToHex)(this.s):void 0}}errorStr(){var o;let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${((o=this.accessList)==null?void 0:o.length)??0}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}W.AccessListEIP2930Transaction=z;var Z={};Object.defineProperty(Z,"__esModule",{value:!0});Z.Transaction=void 0;const M=Te,l=C,oe=ye,Se=U,K=X,hf=0;function Ae(i,e){const o=Number(i),t=Number(e)*2;return o===t+35||o===t+36}class V extends Se.BaseTransaction{constructor(e,o={}){if(super({...e,type:hf},o),this.common=this._validateTxV(this.v,o.common),this.gasPrice=(0,l.bufferToBigInt)((0,l.toBuffer)(e.gasPrice===""?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>l.MAX_INTEGER){const s=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(s)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),Se.BaseTransaction._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?Ae(this.v,this.common.chainId())&&this.activeCapabilities.push(K.Capability.EIP155ReplayProtection):this.activeCapabilities.push(K.Capability.EIP155ReplayProtection)),((o==null?void 0:o.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,o={}){return new V(e,o)}static fromSerializedTx(e,o={}){const t=(0,l.arrToBufArr)(M.RLP.decode(Uint8Array.from(e)));if(!Array.isArray(t))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(t,o)}static fromValuesArray(e,o={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[t,s,n,a,r,d,m,u,h]=e;return(0,l.validateNoLeadingZeroes)({nonce:t,gasPrice:s,gasLimit:n,value:r,v:m,r:u,s:h}),new V({nonce:t,gasPrice:s,gasLimit:n,to:a,value:r,data:d,v:m,r:u,s:h},o)}raw(){return[(0,l.bigIntToUnpaddedBuffer)(this.nonce),(0,l.bigIntToUnpaddedBuffer)(this.gasPrice),(0,l.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:Buffer.from([]),(0,l.bigIntToUnpaddedBuffer)(this.value),this.data,this.v!==void 0?(0,l.bigIntToUnpaddedBuffer)(this.v):Buffer.from([]),this.r!==void 0?(0,l.bigIntToUnpaddedBuffer)(this.r):Buffer.from([]),this.s!==void 0?(0,l.bigIntToUnpaddedBuffer)(this.s):Buffer.from([])]}serialize(){return Buffer.from(M.RLP.encode((0,l.bufArrToArr)(this.raw())))}_getMessageToSign(){const e=[(0,l.bigIntToUnpaddedBuffer)(this.nonce),(0,l.bigIntToUnpaddedBuffer)(this.gasPrice),(0,l.bigIntToUnpaddedBuffer)(this.gasLimit),this.to!==void 0?this.to.buf:Buffer.from([]),(0,l.bigIntToUnpaddedBuffer)(this.value),this.data];return this.supports(K.Capability.EIP155ReplayProtection)&&(e.push((0,l.bigIntToUnpaddedBuffer)(this.common.chainId())),e.push((0,l.unpadBuffer)((0,l.toBuffer)(0))),e.push((0,l.unpadBuffer)((0,l.toBuffer)(0)))),e}getMessageToSign(e=!0){const o=this._getMessageToSign();return e?Buffer.from((0,oe.keccak256)(M.RLP.encode((0,l.bufArrToArr)(o)))):o}getDataFee(){return this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork()?this.cache.dataFee.value:(Object.isFrozen(this)&&(this.cache.dataFee={value:super.getDataFee(),hardfork:this.common.hardfork()}),super.getDataFee())}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=Buffer.from((0,oe.keccak256)(M.RLP.encode((0,l.bufArrToArr)(this.raw()))))),this.cache.hash):Buffer.from((0,oe.keccak256)(M.RLP.encode((0,l.bufArrToArr)(this.raw()))))}getMessageToVerifySignature(){if(!this.isSigned()){const o=this._errorMsg("This transaction is not signed");throw new Error(o)}const e=this._getMessageToSign();return Buffer.from((0,oe.keccak256)(M.RLP.encode((0,l.bufArrToArr)(e))))}getSenderPublicKey(){const e=this.getMessageToVerifySignature(),{v:o,r:t,s}=this;this._validateHighS();try{return(0,l.ecrecover)(e,o,(0,l.bigIntToUnpaddedBuffer)(t),(0,l.bigIntToUnpaddedBuffer)(s),this.supports(K.Capability.EIP155ReplayProtection)?this.common.chainId():void 0)}catch{const a=this._errorMsg("Invalid Signature");throw new Error(a)}}_processSignature(e,o,t){this.supports(K.Capability.EIP155ReplayProtection)&&(e+=this.common.chainId()*BigInt(2)+BigInt(8));const s={...this.txOptions,common:this.common};return V.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:(0,l.bufferToBigInt)(o),s:(0,l.bufferToBigInt)(t)},s)}toJSON(){return{nonce:(0,l.bigIntToHex)(this.nonce),gasPrice:(0,l.bigIntToHex)(this.gasPrice),gasLimit:(0,l.bigIntToHex)(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:(0,l.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),v:this.v!==void 0?(0,l.bigIntToHex)(this.v):void 0,r:this.r!==void 0?(0,l.bigIntToHex)(this.r):void 0,s:this.s!==void 0?(0,l.bigIntToHex)(this.s):void 0}}_validateTxV(e,o){let t;const s=e!==void 0?Number(e):void 0;if(s!==void 0&&s<37&&s!==27&&s!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${s}`);if(s!==void 0&&s!==0&&(!o||o.gteHardfork("spuriousDragon"))&&s!==27&&s!==28)if(o){if(!Ae(BigInt(s),o.chainId()))throw new Error(`Incompatible EIP155-based V ${s} and chain id ${o.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(s-35)%2===0?n=35:n=36,t=BigInt(s-n)/BigInt(2)}return this._getCommon(o,t)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}Z.Transaction=V;var ue={},me={};Object.defineProperty(me,"__esModule",{value:!0});me.normalizeTxParams=void 0;const N=C,lf=i=>{const e=Object.assign({},i);return e.gasLimit=(0,N.toType)(e.gasLimit??e.gas,N.TypeOutput.BigInt),e.data=e.data===void 0?e.input:e.data,e.gasPrice=e.gasPrice!==void 0?BigInt(e.gasPrice):void 0,e.value=e.value!==void 0?BigInt(e.value):void 0,e.to=e.to!==null&&e.to!==void 0?(0,N.setLengthLeft)((0,N.toBuffer)(e.to),20):null,e.v=e.v==="0x0"?"0x":e.v,e.r=e.r==="0x0"?"0x":e.r,e.s=e.s==="0x0"?"0x":e.s,e.v!=="0x"&&(e.v=(0,N.toType)(e.v,N.TypeOutput.BigInt)),e};me.normalizeTxParams=lf;Object.defineProperty(ue,"__esModule",{value:!0});ue.TransactionFactory=void 0;const se=C,He=J,Ce=W,gf=me,ne=Z;class ae{constructor(){}static fromTxData(e,o={}){if(!("type"in e)||e.type===void 0)return ne.Transaction.fromTxData(e,o);{const t=Number((0,se.bufferToBigInt)((0,se.toBuffer)(e.type)));if(t===0)return ne.Transaction.fromTxData(e,o);if(t===1)return Ce.AccessListEIP2930Transaction.fromTxData(e,o);if(t===2)return He.FeeMarketEIP1559Transaction.fromTxData(e,o);throw new Error(`Tx instantiation with type ${t} not supported`)}}static fromSerializedData(e,o={}){if(e[0]<=127)switch(e[0]){case 1:return Ce.AccessListEIP2930Transaction.fromSerializedTx(e,o);case 2:return He.FeeMarketEIP1559Transaction.fromSerializedTx(e,o);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return ne.Transaction.fromSerializedTx(e,o)}static fromBlockBodyData(e,o={}){if(Buffer.isBuffer(e))return this.fromSerializedData(e,o);if(Array.isArray(e))return ne.Transaction.fromValuesArray(e,o);throw new Error("Cannot decode transaction: unknown type input")}static async fromEthersProvider(e,o,t){const s=(0,se.getProvider)(e),n=await(0,se.fetchFromProvider)(s,{method:"eth_getTransactionByHash",params:[o]});if(n===null)throw new Error("No data returned from provider");return ae.fromRPCTx(n,t)}static async fromRPCTx(e,o={}){return ae.fromTxData((0,gf.normalizeTxParams)(e),o)}}ue.TransactionFactory=ae;(function(i){var e=F&&F.__createBinding||(Object.create?function(r,d,m,u){u===void 0&&(u=m);var h=Object.getOwnPropertyDescriptor(d,m);(!h||("get"in h?!d.__esModule:h.writable||h.configurable))&&(h={enumerable:!0,get:function(){return d[m]}}),Object.defineProperty(r,u,h)}:function(r,d,m,u){u===void 0&&(u=m),r[u]=d[m]}),o=F&&F.__exportStar||function(r,d){for(var m in r)m!=="default"&&!Object.prototype.hasOwnProperty.call(d,m)&&e(d,r,m)};Object.defineProperty(i,"__esModule",{value:!0}),i.TransactionFactory=i.Transaction=i.AccessListEIP2930Transaction=i.FeeMarketEIP1559Transaction=void 0;var t=J;Object.defineProperty(i,"FeeMarketEIP1559Transaction",{enumerable:!0,get:function(){return t.FeeMarketEIP1559Transaction}});var s=W;Object.defineProperty(i,"AccessListEIP2930Transaction",{enumerable:!0,get:function(){return s.AccessListEIP2930Transaction}});var n=Z;Object.defineProperty(i,"Transaction",{enumerable:!0,get:function(){return n.Transaction}});var a=ue;Object.defineProperty(i,"TransactionFactory",{enumerable:!0,get:function(){return a.TransactionFactory}}),o(X,i)})(Be);const pf=Re(Be),vf=Ge({__proto__:null,default:pf},[Be]);export{Le as a,Be as d,vf as i};
